**I. USER-CONFIGURED PATHS, ADD-ON SELECTION, COMPONENT DISCOVERY & LOADING:**

A. **Parse User-Configured Paths for Outputs and Specific Inputs:**
    You **must** parse the `[[USER PATH CONFIGURATION]]` block found at the very beginning of *this Master Prompt Segment*. These paths are primarily for directing your outputs and locating some user-provided process-specific inputs.
    *   **User-Configurable Paths (Examples from `[[USER PATH CONFIGURATION]]`):**
        *   `Main Iteration Folder`: Root for current iteration outputs.
        *   `Prompts Folder`: For generated prompts, TLP, and the IEP copy. (Relative to `Main Iteration Folder`)
        *   `Submodule Plan Destination`: For main plan and Task AI `_dev_plan.md` files. (Relative to `Main Iteration Folder`)
        *   `Inter-AI Communication Folder`: For IPC files. (Often same as or within `Prompts Folder`)
        *   `User-Specified Task Output Base Path`: Root for Task AI deliverables. (Relative to repo root)
        *   Process-specific paths like `PRODUCT_NAME`, `PRODUCT_SPECS_INPUT_DOCS_PATH`, etc., are also parsed from here if defined by the user.
    *   If any of these output/process-specific paths are missing from the user's configuration, and an active add-on requires them, that add-on must define its own default behavior or error handling.
    *   All paths you generate for outputs must be constructed clearly, typically relative to the repository root, and reflect these user-specified locations.

B. **Fixed Global System Paths for Core Components:**
    The locations for core framework components (Add-ons, Utils, Base IEP, IPC directory) are fixed and relative to the repository root. You **must** use these hardcoded paths for discovery and loading:
    *   **Add-ons Base Directory:** `prompts/add_ons/`
    *   **Utils Base Directory:** `prompts/util/`
    *   **IEP Base Directory:** `prompts/iep/` (specifically for `Base_IEP.txt`)
    *   **IPC Base Directory:** `prompts/ipc/` (for future IPC components and general IPC file storage)

C. **Discover and Load Add-on Components:**
    1.  **Parse User Add-on Selections:**
        a.  Scan the `[[USER_ADDON_SELECTION]]` block from `Master_Prompt_Segment.txt`.
        b.  Identify lines beginning with `[x]` to extract the selected `addon_app_name`s (these are folder names).
        c.  Compile an ordered list of these: `Selected_Addons_AppNames_Ordered`.
    2.  **Define Known Primary Directive Add-on Apps:**
        `Known_Primary_Directive_Addon_Apps`: A list of `addon_app_name`s recognized as primary directives (e.g., `["task_spawning_addon", "build_product_specs_process"]`).
    3.  **Initialize Collections for Add-ons:**
        *   `Active_Primary_Addon_AppName`: null
        *   `All_Selected_Addons_Content_Map`: An empty map for `addon_app_name: primary_instruction_content`.
        *   `App_Specific_Configs_Content_Map`: An empty map for `addon_app_name: raw_config_block_string`.
        *   `Inheritable_Addons_Content_Ordered_List`: An empty ordered list for content of selected non-primary add-ons.
        *   `Loaded_Primary_Addon_AppNames`: An empty list to track selected primary add-on apps that were successfully loaded.
    4.  **Load Selected Add-on Content & Discover App-Specific Configs:**
        For each `selected_app_name` in `Selected_Addons_AppNames_Ordered`:
        a.  Construct the path to its primary instruction file: `path_to_primary_instruction_file = prompts/add_ons/[selected_app_name]/[selected_app_name].txt`.
        b.  Attempt to read the content of this file.
        c.  If successfully read:
            i.  Store its content in `All_Selected_Addons_Content_Map` with `selected_app_name` as key.
            ii. If `selected_app_name` is in `Known_Primary_Directive_Addon_Apps`:
                *   Add `selected_app_name` to `Loaded_Primary_Addon_AppNames`.
                *   If `Active_Primary_Addon_AppName` is still null, set `Active_Primary_Addon_AppName = selected_app_name`.
            iii. **Scan Main Prompt for App-Specific Configuration Block:**
                *   Define delimiters: `start_delim = "[[USER_CONFIG_FOR_" + selected_app_name + "]]"`, `end_delim = "[[END_USER_CONFIG_FOR_" + selected_app_name + "]]"`.
                *   Search the *entire original user-provided main spawn prompt file content* (the one that contained the `[[MASTER_PROMPT_SEGMENT]]` block) for text between these delimiters.
                *   If found, extract the raw string content (exclusive of the delimiters) and store it in `App_Specific_Configs_Content_Map` with `selected_app_name` as the key. If not found, store an empty string or a specific marker (e.g., `_NOT_FOUND_`) for this `selected_app_name`.
        d.  If the primary instruction file is not found or unreadable: Prepare a warning: "Warning: Selected add-on app '[selected_app_name]' is missing its primary instruction file at '[path_to_primary_instruction_file]' and will be skipped." Do not add it to any collections.
    5.  **Populate Inheritable Add-ons List:**
        For each `loaded_app_name` in `Selected_Addons_AppNames_Ordered` (iterate based on original selection order, but only consider apps successfully loaded into `All_Selected_Addons_Content_Map`):
        a.  If `loaded_app_name` is NOT equal to `Active_Primary_Addon_AppName`, add its content (from `All_Selected_Addons_Content_Map[loaded_app_name]`) to `Inheritable_Addons_Content_Ordered_List`.
    6.  **Handle Multiple Selected Primary Add-ons:** If `Loaded_Primary_Addon_AppNames` contains more than one app name, prepare a note/warning as specified previously. This note must be included in any summary or commit message.
    7.  If `[[USER_ADDON_SELECTION]]` was not found or no add-ons were marked `[x]`, relevant collections will be empty.
    8.  The `Active_Primary_Addon_AppName`, `All_Selected_Addons_Content_Map`, and `App_Specific_Configs_Content_Map` are used for execution logic in Section II.
    9.  The `Inheritable_Addons_Content_Ordered_List` is for use by the `Active_Primary_Addon_AppName` if it generates sub-prompts.

D. **Input Definition Files (Base IEP):**
    The Base IEP content is loaded from the fixed path `prompts/iep/Base_IEP.txt`. This will be referenced in Section III.C.1.

E. **Discover and Load Utility Components ("Utils"):**
    1.  **Scan for Available Util "Apps":**
        a.  Identify all subdirectories within the fixed path `prompts/util/`. Each subdirectory name is a `util_app_name`.
    2.  **Initialize Collection:** `All_Available_Utils_Content_Map` (empty map for `util_app_name: content`).
    3.  **Load Util Content:** For each `util_app_name`:
        a.  Path: `prompts/util/[util_app_name]/[util_app_name].txt`.
        b.  If readable, store in map. Otherwise, prepare warning.
    4.  **Availability:** Utils are available for explicit use by other components via `All_Available_Utils_Content_Map`.

**II. ADD-ON EXECUTION AND CONDITIONAL LOGIC:**

A. **Process Active Primary Add-on (if any):**
    1.  If `Active_Primary_Addon_AppName` (identified in I.C.4) is not null:
        a.  Retrieve its primary instruction content from `All_Selected_Addons_Content_Map`.
        b.  Retrieve its app-specific config string from `App_Specific_Configs_Content_Map` (it might be empty or the not-found marker).
        c.  Execute its instructions. The add-on is responsible for parsing its specific config string if provided. It should use `Inheritable_Addons_Content_Ordered_List` for appending to sub-prompts.
        d.  Other add-ons in `Inheritable_Addons_Content_Ordered_List` are supplementary.
    2.  **If `Active_Primary_Addon_AppName` IS NULL:** (Logic as before, referring to app names)
        a.  State no active primary add-on was selected/found.
        b.  If `Inheritable_Addons_Content_Ordered_List` is not empty, state intent to process these. For each, retrieve its app-specific config string. Execute if self-executing and makes sense; be cautious.
        c.  Generate `Information_Exchange_Protocol.md`.
        d.  Conclude operations.

**III. OUTPUT GENERATION REQUIREMENTS (Core Utilities):**

C. **Supporting Documentation (Core Utilities):**
1.  **`Information_Exchange_Protocol.md`:**
    *   (Condition for generation as before).
    *   Load from `prompts/iep/Base_IEP.txt`.
    *   Create in 'Prompts Folder' (user-configured output path).

**IV. FINAL INSTRUCTION TO PLANNING AI & SELF-CORRECTION (Core):**

B. **Final Commit Message by Planning AI:**
    (Task-ID and notes should reflect `Active_Primary_Addon_AppName` and any warnings about missing app-specific config blocks if an add-on expected one but it wasn't found, in addition to other existing notes.)
    Adhere to IEP (from `prompts/iep/Base_IEP.txt`).
    *   Task-ID: e.g., "PROCESSED_PRIMARY_ADDON_[Active_Primary_Addon_AppName]" or "CORE_UTILITY_PROCESSING_ONLY".
    *   Notes:
        *   `Active_Primary_Addon_AppName` processed.
        *   Warnings for multiple primary selections, missing add-on/util files.
        *   Summary of other add-ons processed from `Inheritable_Addons_Content_Ordered_List`.
        *   Note if any selected add-on expected an app-specific config block (e.g. `[[USER_CONFIG_FOR_...]]`) but it was not found in the main spawn prompt.
        *   Self-checks, confidence, etc. as before.
