# MPS Usage Guide (for Canonical Framework using `prompts/Master_Prompt_Segment.txt`)

## 1. Introduction
This guide explains how to use the canonical `Master_Prompt_Segment.txt` (located at `/prompts/Master_Prompt_Segment.txt` in this framework's development repository) to instruct a Planning AI. The `Master_Prompt_Segment.txt` has been modularized. Its core instructional logic for parsing configurations and managing add-ons resides in `/prompts/iep/Core_Planning_Instructions.txt`. Notably, the primary project planning and task generation functionality is now encapsulated in an optional add-on, `prompts/add_ons/task_spawning_addon.txt`. This structure enhances maintainability and flexibility, allowing the framework to be adapted for various purposes beyond full-scale project planning if desired.

## 2. Core Components You Will Use/Prepare

*   **Content of `/prompts/Master_Prompt_Segment.txt` from this framework repo:** This text serves as the main wrapper for the Planning AI's instructions. You will copy its *content* into your main spawn prompt file. **Crucially, you must edit the `[[USER PATH CONFIGURATION]]` and `[[USER_ADDON_SELECTION]]` blocks at the top of the MPS content you copied to suit your target project.** This file now primarily contains user configuration sections and an include directive to load `/prompts/iep/Core_Planning_Instructions.txt`.

*   **Content of `/prompts/iep/Core_Planning_Instructions.txt` from this framework repo:** This file contains foundational instructions for the Planning AI. It dictates how the AI parses user configurations (paths and add-on selections from `Master_Prompt_Segment.txt`), loads add-on files (including filtering for inheritance), and implements the conditional logic for primary functionalities like task spawning. It also includes instructions for generating utility files like `Information_Exchange_Protocol.md`. You **must** copy its *content* to `/prompts/iep/Core_Planning_Instructions.txt` in your target repository, as it's essential for the framework's operation.

*   **Content of `/prompts/iep/Base_IEP.txt` from this framework repo:** This is the Base Information Exchange Protocol. You will copy its *content* to `/prompts/iep/Base_IEP.txt` in your target repository.

*   **Content of Add-on Files (from `/prompts/add_ons/` in this framework repo):**
    *   Add-ons provide specific functionalities. You select them in the `[[USER_ADDON_SELECTION]]` block. For any add-on you wish to use, copy its content to the corresponding path in `/prompts/add_ons/` in your target repository.
    *   **Key Add-on for Planning: `task_spawning_addon.txt`**: This add-on contains all instructions for the Planning AI to perform its traditional role: generating a main development plan, a Task Launch Plan (TLP), and individual task prompt files. **If you want the AI to generate a project plan, you MUST select this add-on and copy its file.** Its content is for the Planning AI's use and is NOT directly inherited by the Task AI prompts it generates.
    *   **Other Inheritable Add-ons** (e.g., `task_resumption_addon.txt`): These provide supplementary instructions intended for the Task AIs. Their content *will* be appended to the task prompts generated by `task_spawning_addon.txt`. The order in which you list these in `[[USER_ADDON_SELECTION]]` will be preserved.
    *   Refer to `/prompts/add_ons/available_addons_manifest.md` for a list and descriptions of available add-ons.

*   **Your Project-Specific Request:** E.g., the "gritos Dev Plan (a003)" text, which is the input the Planning AI will work on if `task_spawning_addon.txt` is selected, or specific inputs for other primary add-ons.

## 3. Setting up Your Target Repository & Crafting the Main Spawn Prompt

To have a Planning AI operate on your project (e.g., "gritos"):

**A. Prepare Your Target Repository (where Planning AI will run):**
1.  Ensure all your project-specific input documents (e.g., for gritos: `gritos_product_specification.md`, `concept/research/` files, etc.) are present at the paths your project request will refer to.
2.  Create a `/prompts/` directory at the root of your target repository.
3.  Inside `target_repo/prompts/`, create an `iep/` subdirectory.
    *   Copy the content from this framework's `/prompts/iep/Base_IEP.txt` into `target_repo/prompts/iep/Base_IEP.txt`.
    *   Copy the content from this framework's `/prompts/iep/Core_Planning_Instructions.txt` into `target_repo/prompts/iep/Core_Planning_Instructions.txt`. (This is mandatory for the framework to function).
4.  Inside `target_repo/prompts/`, create an `add_ons/` subdirectory.
    *   **If you want the Planning AI to generate a project plan, TLP, and task prompts**, you **must** copy the content of `task_spawning_addon.txt` from this framework's `/prompts/add_ons/task_spawning_addon.txt` to `target_repo/prompts/add_ons/task_spawning_addon.txt`.
    *   Similarly, if using other primary function add-ons (like `build_product_specs_process.txt`), copy them here.
    *   For any other supplementary add-ons you intend to use (e.g., `task_resumption_addon.txt`), copy their content from this framework's `/prompts/add_ons/` directory into the corresponding file in `target_repo/prompts/add_ons/`.
5.  The Planning AI will create its output "Prompts Folder" (e.g., `prompts/tasks/` or as specified by you in `[[USER PATH CONFIGURATION]]`) if directed by an active add-on like `task_spawning_addon.txt`.

**B. Create Your Main Spawn Prompt File in Target Repository:**
   (e.g., `target_repo/prompts/p_your_project_spawn.txt` - refer to `framework_dev_docs/guides/p_gritos_dev_plan_spawn_EXAMPLE.md` in this framework repo for a structural example)

   This file must contain, in order:
    1.  **Your Specific Project Request:** (e.g., the "gritos Dev Plan (a003)..." text). This is primarily used if `task_spawning_addon.txt` is active, or if another primary add-on requires specific input here.
    2.  **The Full Content of `/prompts/Master_Prompt_Segment.txt` (from this framework repo), with its top `[[USER PATH CONFIGURATION]]` and `[[USER_ADDON_SELECTION]]` blocks EDITED BY YOU for your target project.**

        **3.B.1. Configuring `[[USER PATH CONFIGURATION]]`**
        This block at the top of the `Master_Prompt_Segment.txt` content is where you define key paths and variables. The Planning AI parses these based on instructions in `Core_Planning_Instructions.txt`. You **must** edit the example values to match your target repository structure and project needs.

        *   **General Project & Task Spawning Paths:**
            These are primarily used by `task_spawning_addon.txt` and other general-purpose add-ons.
            *   `Main Iteration Folder`: The root for all Planning AI outputs for this project iteration. Use `.` for the repository root, or a relative path (e.g., `project_X_outputs`).
            *   `Prompts Folder`: Subdirectory for generated task prompts, TLP, and the copied IEP file. Relative to `Main Iteration Folder`.
            *   `Submodule Plan Destination`: Directory for the main project plan (if `task_spawning_addon.txt` is used) and individual Task AI `_dev_plan.md` files. Relative to `Main Iteration Folder`.
            *   `Inter-AI Communication Folder`: Subdirectory for IPC files, typically nested within `Prompts Folder`.
            *   `User-Specified Task Output Base Path`: The root path where Task AIs will place their primary deliverables (e.g., code). This path is relative to the repository root.

        *   **Paths for Specific Processes/Add-ons (Examples):**
            Some add-ons may require their own set of path configurations. These should also be defined in the `[[USER PATH CONFIGURATION]]` block if you intend to use such add-ons.
            *   **For "Build Product Specs" Process (used by the `build_product_specs_process.txt` add-on):**
                *   `PRODUCT_NAME`: (Example: `"NovaSystem"`) The name of your product. Used for naming output files and internal references.
                *   `PRODUCT_SPECS_INPUT_DOCS_PATH`: (Example: `product_dev/inputs`) Path relative to the repository root, pointing to a folder containing primary input documents for product specification generation, such as market research, user feedback, competitive analysis, etc.
                *   `PRODUCT_SPECS_GUIDANCE_DOCS_PATH`: (Example: `product_dev/guidance`) Path relative to the repository root, pointing to a folder containing documents that provide rules, constraints, and guidance for product development. This includes branding guides, compliance requirements, technical constraints, style guides, etc.
                *   `PRODUCT_SPECS_OUTPUT_PATH`: (Example: `product_dev/specifications`) Path relative to the repository root, specifying the folder where the AI should save the generated product specification documents (e.g., Product Requirements Document (PRD), Market Requirements Document (MRD), technical specifications).
                *   `PRODUCT_SPECS_PRIMARY_INPUT_FILE`: (Example: `product_dev/inputs/main_requirements_document.md`) **Optional.** Path relative to the repository root to a specific document within `PRODUCT_SPECS_INPUT_DOCS_PATH` (or elsewhere if an absolute path is provided, though relative is recommended). If specified, the AI is guided to use this document as the central point for its heading-based research phase.
                *   `PRODUCT_SPECS_REF_DEPTH`: (Example: `1`) **Optional.** An integer (0, 1, or 2) specifying the depth for following internal document references during the research phase. 
                    - `0`: No internal references will be followed.
                    - `1`: Only directly referenced documents will be consulted.
                    - `2`: Documents referenced by directly referenced documents may also be consulted.
                    If not specified or if an invalid value is provided, the AI will default to a depth of 1.
                *   `PRODUCT_SPECS_CODEBASE_REVIEW_PREFERENCE`: (Example: `cursory`) **Optional.** Specifies how the AI should approach reviewing any codebase links found in input documents. Valid options:
                    - `complex`: AI attempts its most detailed analysis of fetched code text. This can be time-consuming.
                    - `cursory` (Default): AI performs a brief review (e.g., reads file names, overall structure, comments if readily available from fetched text) and primarily reports the link for human review if full, deep analysis seems difficult or too extensive from the fetched text representation.
                    - `focused`: AI attempts to narrow its analysis of fetched code text based on keywords provided in `PRODUCT_SPECS_CODEBASE_FOCUS_AREAS` or other contextual cues from the input documents.
                *   `PRODUCT_SPECS_CODEBASE_FOCUS_AREAS`: (Example: `"authentication, API integration, data validation"`) **Optional.** A comma-separated list of keywords or phrases. This is used only if `PRODUCT_SPECS_CODEBASE_REVIEW_PREFERENCE` is set to "focused". It helps guide the AI's attention to specific parts or aspects of any linked codebase it reviews.

        **3.B.2. Configuring `[[USER_ADDON_SELECTION]]`**
        This block allows you to specify which add-on functionalities you want to activate.
            *   **Order of Inheritable Add-ons:** If `task_spawning_addon.txt` is selected, other add-ons (like `task_resumption_addon.txt`, coding standards, etc.) are considered "inheritable" by Task AIs. Their content will be appended to generated task prompts in the order you list them here.
            *   **`task_spawning_addon.txt` Placement:** It's recommended to list `task_spawning_addon.txt` last if you select it. This visually represents its role as the primary orchestrator for planning and task generation, using other listed add-ons as inputs.
        *   **Example `[[USER_ADDON_SELECTION]]` for full planning:**
            ```
            [[USER_ADDON_SELECTION]]
            # Inheritable add-ons - order matters for task prompts
            [x] task_resumption_addon.txt               # Example: Provides task state resumption.
            # [ ] example_coding_standards_addon.txt    # Example: Could provide coding standards.
            
            # Primary Orchestrating Add-on
            [x] task_spawning_addon.txt  # Enables project planning & task generation.
            [[END USER_ADDON_SELECTION]]
            ```
        *   If you do *not* select `task_spawning_addon.txt`, the AI will not generate a project plan unless another selected add-on provides such specific instructions.

**C. Invoke the Planning AI:**
   Provide the simple prompt to your Planning AI, pointing to the spawn prompt file you just created in your target repository:
   `"/prompts/p_your_project_spawn.txt is the prompt, it is in the repo"` (adjust path if you named or placed it differently).

The Planning AI will then:
1.  **Read your spawn prompt.**
2.  **Process Core Instructions:** It will first process the included `/prompts/iep/Core_Planning_Instructions.txt`. This involves:
    *   Parsing the `[[USER PATH CONFIGURATION]]` to understand where to read inputs and place outputs, including any process-specific paths you've defined.
    *   Parsing the `[[USER_ADDON_SELECTION]]` to identify which add-on files to load from `/prompts/add_ons/` in your target repository. This step also prepares a filtered list of "inheritable" add-on content (excluding the active primary add-on itself) for potential use by that primary add-on.
3.  **Conditional Add-on Execution:**
    *   **If `task_spawning_addon.txt` IS SELECTED** (and is the active primary add-on):
        *   The AI will load and execute the instructions from `task_spawning_addon.txt`. This will lead to the primary planning activities: interpretation of your project request, generation of a main development plan (e.g., `project_dev_plan.md`), a `00_task_launch_plan.md`, and individual task prompt files.
        *   When generating task prompts, `task_spawning_addon.txt` will append the content of other selected, inheritable add-ons (e.g., `task_resumption_addon.txt`) in the order they were listed in `[[USER_ADDON_SELECTION]]`. **The content of the active primary add-on itself is NOT appended to the Task AI prompts**; it is solely for the Planning AI's use. This keeps Task AI prompts focused on their specific tasks plus any supplementary (inheritable) instructions.
        *   Outputs will be placed according to your `[[USER PATH CONFIGURATION]]`.
    *   **If other primary directive add-ons ARE SELECTED** (e.g., `build_product_specs_process.txt` is the active primary add-on): The AI will execute the instructions from that add-on, using any specific path configurations you've provided for it (like `PRODUCT_SPECS_INPUT_DOCS_PATH`, `PRODUCT_SPECS_PRIMARY_INPUT_FILE`, `PRODUCT_SPECS_REF_DEPTH`, `PRODUCT_SPECS_CODEBASE_REVIEW_PREFERENCE` etc.). If that primary add-on is designed to create further sub-prompts (currently `build_product_specs_process.txt` is not), it would also use the inheritable add-on list.
    *   **If NO primary directive add-on IS SELECTED**:
        *   The AI will acknowledge this and will **not** generate a main development plan, TLP, or task prompts by default.
        *   It will proceed to load and execute any *other* add-ons you have selected (based on their content from `All_Selected_Addons_Content_Map` as per `Core_Planning_Instructions.txt`). These add-ons must provide their own complete directives if they are to perform significant actions.
        *   If no other primary directive add-ons are selected, the AI will perform minimal actions (e.g., generate `Information_Exchange_Protocol.md` as per `Core_Planning_Instructions.txt`), report that no main planning tasks were performed, and await further instructions or conclude its operations.
4.  **Read Supporting Files:** It will read `Base_IEP.txt` and the content of all successfully located selected add-ons from your target repository as needed.

This modular approach provides greater flexibility. While the full planning and task generation capabilities are available via `task_spawning_addon.txt`, you can also use the MPS framework with other add-ons for different purposes, or develop new add-ons with unique functionalities.
